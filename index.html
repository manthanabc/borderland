<html>
<body>
<div id="main">
  <DIV class="trig">
  </DIV>
</div>
<style>
.trig {
    position: absolute;
    top: 200;
    left: 200;
    width: 0px;
    height: 0px;
    border: solid;
    border-right: 50px solid transparent;
    border-left: 50px solid transparent;
    border-top: 50px solid transparent;
    border-bottom: 50px solid teal;
}
</style>
<script>

let parent = document.getElementById('main');
let tris = [];
let counter =0;

class vector {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  normalize() {
    this.magnitude = Math.sqrt(this.x*this.x + this.y*this.y)
    this.x /= this.magnitude;
    this.y /= this.magnitude;
  }
}

class triangle {
  constructor(t1, t2, t3) {
    this.t1= t1;
    this.t2= t2;
    this.t3= t3;
  }
}
class rendertrig {
  constructor(t1) {
    this.trig = t1;
    this.id = counter++;
  }
  init() {
    let elm = document.createElement('div');
    elm.style=`top: ${Math.random()*600}; left: ${Math.random()*600}; border-color:#${Math.random()*100}`;
    parent.appendChild(elm);
    this.elm = elm
    this.color = '#30'+(Math.random() * 0xFFFF << 0).toString(16).padStart(4, '0') + '50';
  }
  draw() {
    let tg = this.trig
    let y=this.elm//document.getElementsByClassName('trig')[0]
    let distbase = dist(tg.t2.x, tg.t2.y, tg.t3.x, tg.t3.y); 

    let sign = (tg.t2.x - tg.t1.x) * (tg.t3.y - tg.t1.y) - (tg.t3.x - tg.t1.x) * (tg.t2.y - tg.t1.y);
    if(sign<0) { sign = -1 } else { sign=1 }
    <!-- console.log(sign) -->
  
    // TODO: Somehow choose the rightmost point correctly its either t2 or t3
  
    let distup, npx, npy
    if(sign < 0) {
      distup =   dist(tg.t2.x, tg.t2.y, tg.t1.x, tg.t1.y); 
      npx = -Math.cos(tg.t2.angle *Math.PI/ 180) * distup + tg.t1.x
      npy = Math.sin(tg.t2.angle*Math.PI/ 180) * distup + tg.t1.y
    } else {
      distup =   dist(tg.t3.x, tg.t3.y, tg.t1.x, tg.t1.y); 
      npx = -Math.cos(tg.t3.angle *Math.PI/ 180) * distup + tg.t1.x
      npy = Math.sin(tg.t3.angle*Math.PI/ 180) * distup + tg.t1.y
    }
    // the rest will work fine
    //npx is the down left most arrow of the triangle

    let borderBottom = npy-tg.t1.y
    let borderLeft = tg.t1.x -npx
    let borderRight = -tg.t1.x + npx + distbase
    // elm
    y.style.top = tg.t1.y;
    y.style.left = tg.t1.x;
    y.style['border-bottom'] = `${borderBottom}px solid ${this.color}`
    y.style['border-left'] = `${borderLeft}px solid transparent`
    y.style['border-right'] = `${borderRight}px solid transparent`
    y.style['border-top'] = `0px solid transparent`


    let baseangle = 90 - Math.atan( (tg.t2.x - tg.t3.x)/(tg.t2.y - tg.t3.y) ) * 180/Math.PI;
    if(tg.t2.y<tg.t3.y) baseangle+=180
    baseangle = 360-baseangle

    baseangle += (sign < 0)? 180 : 0; 

    let rotx = tg.t1.x - borderLeft + (borderLeft + borderRight)/2;
    let roty = tg.t1.y + borderBottom/2;

    baseangle *=-1
    y.className = 'trig'
    y.style['transform'] = `translateX(-${borderLeft}px) translate(${tg.t1.x-rotx}px, -${ borderBottom/2 }px) rotate(${baseangle}deg) translate(${-tg.t1.x+rotx}px, ${ borderBottom/2 }px)`;
  }
}

class vertex {
  constructor(x, y, angle) {
    this.x = x;
    this.y = y;
    this.angle  = angle;
  }
}

let draw = (x, y, color) => {
  <!-- let elm = document.createElement('div'); -->
  <!-- elm.className='trig'; -->
  <!-- elm.style=`top: ${y}; left: ${x}; border: solid ${color};`; -->
  <!-- parent.appendChild(elm) -->
}

let dist = (x1, y1, x2, y2) => {
  return Math.sqrt(Math.pow(x1-x2, 2) + Math.pow(y1-y2, 2));
}

let p1x=420;
let p1y=590;

let p2x=330;
let p2y=180;

let p3x=550;
let p3y=470;


draw(p1x, p1y, 'pink')
draw(p3x, p3y, 'blue')

class Point2d {
  constructor(x, y) {
    this.x  = x;
    this.y  = y;
  }
}
let angle = 0;
class Point3d {
  constructor(x, y, z) {
    let a = this.rotate(x, y, z, angle)
    this.x = a[0]*20 + 500;
    this.y = a[1]*20 + 500; 
    this.z = a[2]+15;
  }
  get() {
    this.p2 = new Point2d(this.x, this.y);
    let sf = Math.pow(this.z, 0.2+0.0001)
    this.p2.x /= sf;
    this.p2.y /= sf;
    return this.p2;
  }

  rotate(x, y, z, angle_deg) {
      let angle_rad = angle_deg * Math.PI / 180.0;
      let a = [0, 0, 0 ]
      let s = Math.sin(angle_rad);
      let c =Math.cos(angle_rad);
      <!-- z -= 100; -->
      a[0] = x * c - z * s;
      a[1] = y ;
      a[2] = x * s + z * c;
      <!-- a[2] += 100; -->

      return [a[0], a[1], a[2]];
  }
}

let compute =(p1, p2 ,p3) => {

  let v1 = new vector(p1.x-p2.x, p1.y-p2.y);
  let v2 = new vector(p3.x-p2.x, p3.y-p2.y);
  let v3 = new vector(p1.x-p3.x, p1.y-p3.y);

  v1.normalize(); v2.normalize(); v3.normalize();

  let angle = Math.acos((v1.x*v2.x)+(v1.y*v2.y));
  let angle2 = Math.acos((v1.x*v3.x)+(v1.y*v3.y));
  
  angle = angle*180/Math.PI;
  angle2 = angle2*180/Math.PI;
  let angle3 = 180 - angle - angle2;

  let t1 = new vertex(p1.x, p1.y, angle2);
  let t2 = new vertex(p2.x, p2.y, angle);
  let t3 = new vertex(p3.x, p3.y, angle3);

  let tg;

  if(t1.angle >= t2.angle && t1.angle >= t3.angle) {
      tg = new triangle(t1, t3, t2);
  }
  else if(t2.angle >= t1.angle && t2.angle >= t3.angle) {
      tg = new triangle(t2, t3, t1); 
  }
  else if(t3.angle >= t1.angle && t3.angle >= t2.angle) {
     tg = new triangle(t3, t1, t2); 
  }

  let p = new rendertrig(tg);
  p.init();
  p.draw();
}

let cube = () => {      
      compute(
          new Point3d(-5, -5, -5).get(), 
          new Point3d(5, -5, -5).get(), 
          new Point3d(5, 5, -5).get()
      );
      compute(
          new Point3d(-5, 5, -5).get(), 
          new Point3d(-5, -5, -5).get(), 
          new Point3d(5, 5, -5).get()
      );

      // Define vertices in the z = 5 plane
      compute(
          new Point3d(-5, -5, 5).get(), 
          new Point3d(5, -5, 5).get(), 
          new Point3d(5, 5, 5).get()
      );
      compute(
          new Point3d(-5, 5, 5).get(), 
          new Point3d(-5, -5, 5).get(), 
          new Point3d(5, 5, 5).get()
      );

      // Define vertical edges connecting the top and bottom faces
      compute(
          new Point3d(-5, -5, -5).get(), 
          new Point3d(-5, -5, 5).get(), 
          new Point3d(-5, 5, 5).get()
      );
      compute(
          new Point3d(-5, 5, -5).get(), 
          new Point3d(-5, -5, -5).get(), 
          new Point3d(-5, 5, 5).get()
      );
      compute(
          new Point3d(5, -5, -5).get(), 
          new Point3d(5, -5, 5).get(), 
          new Point3d(5, 5, 5).get()
      );
      compute(
          new Point3d(5, 5, -5).get(), 
          new Point3d(5, -5, -5).get(), 
          new Point3d(5, 5, 5).get()
      );      new Point3d(p1x, p1y)

}

document.onmousemove = handleMouseMove;
function handleMouseMove(event) {
    var eventDoc, doc, body;
    <!-- console.log(event.pageX + ' ' + event.pageY) -->
    p2x = event.pageX;
    p2y = event.pageY;
    if(Math.random() > 0.1) {
      parent.innerHTML = ""
      console.log(angle)
      angle += 1
      cube();
    }
}

</script>
</BODY>
</HTML>
