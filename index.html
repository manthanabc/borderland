<html>
<body>
<div id="main">
</div>
<style>
.trig {
    position: absolute;
    top: 200;
    left: 200;
    width: 0px;
    height: 0px;
    border: solid;
    border-right: 50px solid transparent;
    border-left: 50px solid transparent;
    border-top: 50px solid transparent;
    border-bottom: 50px solid teal;
}
</style>
<script>

let parent = document.getElementById('main');
let tris = [];
let counter =0;

class vector {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  normalize() {
    this.magnitude = Math.sqrt(this.x*this.x + this.y*this.y)
    this.x /= this.magnitude;
    this.y /= this.magnitude;
  }
}

class triangle {
  constructor(t1, t2, t3) {
    this.t1= t1;
    this.t2= t2;
    this.t3= t3;
  }
}

let convert2d = (p1) => {
  let a = rotate(p1)
  p2 = new Point2d(a[0]*20 + 500, a[1]*20 + 500);
  let sf = Math.pow(a[2]+15, 0.2+0.0001)
  p2.x /= sf;
  p2.y /= sf;
  p2.x += 0.1;
  return p2;
}

rotate = (p) => {
    let angle_rad = angle * Math.PI / 180.0; 
    <!-- angle_rad = 0; -->
    let a = [0, 0, 0 ]
    let s = Math.sin(angle_rad);
    let c =Math.cos(angle_rad);
    <!-- z -= 100; -->
    a[0] = p.x * c - p.z * s;
    a[1] = p.y ;
    a[2] = p.x * s + p.z * c;
    return a;
}

class rendertrig {
  constructor(p1, p2, p3) {
    this.p1 = p1;
    this.p2 = p2;
    this.p3 = p3;
    this.id = counter++;
  }
  init() {
    let elm = document.createElement('div');
    elm.style=`top: ${Math.random()*600}; left: ${Math.random()*600}; border-color:#${Math.random()*100}`;
    parent.appendChild(elm);
    this.elm = elm
    this.color = '#30'+(Math.random() * 0xFFFF << 0).toString(16).padStart(4, '0') + '80';
  }
  draw() {
    let p1 =convert2d(this.p1);
    let p2 =convert2d(this.p2);
    let p3 =convert2d(this.p3);
    
    let v1 = new vector(p1.x-p2.x, p1.y-p2.y);
    let v2 = new vector(p3.x-p2.x, p3.y-p2.y);
    let v3 = new vector(p1.x-p3.x, p1.y-p3.y);

    v1.normalize(); v2.normalize(); v3.normalize();

    let angle = Math.acos((v1.x*v2.x)+(v1.y*v2.y));
    let angle2 = Math.acos((v1.x*v3.x)+(v1.y*v3.y));
  
    angle = angle * (180/Math.PI);
    angle2 = angle2 * (180/Math.PI);
    let angle3 = 180 - angle - angle2;

    let t1 = new vertex(p1.x, p1.y, p1.z, angle2);
    let t2 = new vertex(p2.x, p2.y, p1.z, angle);
    let t3 = new vertex(p3.x, p3.y, p1.z, angle3);

    let tg;

    if(t1.angle >= t2.angle && t1.angle >= t3.angle) {
        tg = new triangle(t1, t3, t2);
    }
    else if(t2.angle >= t1.angle && t2.angle >= t3.angle) {
        tg = new triangle(t2, t3, t1); 
    }
    else if(t3.angle >= t1.angle && t3.angle >= t2.angle) {
       tg = new triangle(t3, t1, t2); 
    }
  
    let y=this.elm//document.getElementsByClassName('trig')[0]
    let distbase = dist(tg.t2.x, tg.t2.y, tg.t3.x, tg.t3.y); 

    let sign = (tg.t2.x - tg.t1.x) * (tg.t3.y - tg.t1.y) - (tg.t3.x - tg.t1.x) * (tg.t2.y - tg.t1.y);
    if(sign<0) { sign = -1 } else { sign=1 }
  
    let distup, npx, npy
    if(sign < 0) {
      distup =   dist(tg.t2.x, tg.t2.y, tg.t1.x, tg.t1.y); 
      npx = -Math.cos(tg.t2.angle *Math.PI/ 180) * distup + tg.t1.x
      npy = Math.sin(tg.t2.angle*Math.PI/ 180) * distup + tg.t1.y
    } else {
      distup =   dist(tg.t3.x, tg.t3.y, tg.t1.x, tg.t1.y); 
      npx = -Math.cos(tg.t3.angle *Math.PI/ 180) * distup + tg.t1.x
      npy = Math.sin(tg.t3.angle*Math.PI/ 180) * distup + tg.t1.y
    }
    // the rest will work fine
    //npx is the down left most arrow of the triangle

    let borderBottom = npy-tg.t1.y
    let borderLeft = tg.t1.x -npx
    let borderRight = -tg.t1.x + npx + distbase
    // elm
    y.style.top = tg.t1.y;
    y.style.left = tg.t1.x;
    y.style['border-bottom'] = `${borderBottom}px solid ${this.color}`
    y.style['border-left'] = `${borderLeft}px solid transparent`
    y.style['border-right'] = `${borderRight}px solid transparent`
    y.style['border-top'] = `0px solid transparent`


    let baseangle = 90 - Math.atan( (tg.t2.x - tg.t3.x)/(tg.t2.y - tg.t3.y) ) * 180/Math.PI;
    if(tg.t2.y<tg.t3.y) baseangle+=180
    baseangle = 360-baseangle

    baseangle += (sign < 0)? 180 : 0; 

    let rotx = tg.t1.x - borderLeft + (borderLeft + borderRight)/2;
    let roty = tg.t1.y + borderBottom/2;

    baseangle *=-1
    y.className = 'trig'
    y.style['transform'] = `translateX(-${borderLeft}px) translate(${tg.t1.x-rotx}px, -${ borderBottom/2 }px) rotate(${baseangle}deg) translate(${-tg.t1.x+rotx}px, ${ borderBottom/2 }px)`;
  }
}

class vertex {
  constructor(x, y, z, angle) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.angle  = angle;
  }
}


// Draw a div at given cordinates for debugging
let draw = (x, y, color) => {
  let elm = document.createElement('div');
  elm.className='trig';
  elm.style=`top: ${y}; left: ${x}; border: solid ${color};`;
  parent.appendChild(elm)
}

let dist = (x1, y1, x2, y2) => {
  return Math.sqrt(Math.pow(x1-x2, 2) + Math.pow(y1-y2, 2));
}

let angle = 45;

class Point2d {
  constructor(x, y) {
    this.x  = x;
    this.y  = y;
  }
}

class Point3d {
  constructor(x, y, z) {
    this.x = x;
    this.y = y; 
    this.z = z;
  }
}

let cube = []
let makecube = () => {
      
      cube.push(new rendertrig(
          new Point3d(-5, -5, -5), 
          new Point3d(5, -5, -5), 
          new Point3d(5, 5, -5)
      ));
      cube.push(new rendertrig(
          new Point3d(-5, 5, -5), 
          new Point3d(-5, -5, -5), 
          new Point3d(5, 5, -5)
      ));

      // Define vertices in the z = 5 plane
      cube.push(new rendertrig(
          new Point3d(-5, -5, 5), 
          new Point3d(5, -5, 5), 
          new Point3d(5, 5, 5)
      ));
      cube.push(new rendertrig(
          new Point3d(-5, 5, 5), 
          new Point3d(-5, -5, 5), 
          new Point3d(5, 5, 5)
      ));

      // Define vertical edges connecting the top and bottom faces
      cube.push(new rendertrig(
          new Point3d(-5, -5, -5), 
          new Point3d(-5, -5, 5), 
          new Point3d(-5, 5, 5)
      ));
      cube.push(new rendertrig(
          new Point3d(-5, 5, -5), 
          new Point3d(-5, -5, -5), 
          new Point3d(-5, 5, 5)
      ));
      cube.push(new rendertrig(
          new Point3d(5, -5, -5), 
          new Point3d(5, -5, 5), 
          new Point3d(5, 5, 5)
      ));
      cube.push(new rendertrig(
          new Point3d(5, 5, -5), 
          new Point3d(5, -5, -5), 
          new Point3d(5, 5, 5)
      ));
}

for(let i=0; i<200; i++) {
  makecube();
}
cube.forEach((trig) => {
  trig.init();
})
let renderCube = () => {
  cube.forEach((trig) => {
    trig.draw();
  })
}


document.onmousemove = handleMouseMove;
function handleMouseMove(event) {
    if(Math.random() > 0.05) {
      var eventDoc, doc, body;
      p2x = event.pageX;
      p2y = event.pageY;
      angle += 1
      renderCube();
    }
}

</script>
</BODY>
</HTML>
